<!DOCTYPE html>
<html>

<head>
  <style>
    :root {
      /* Minimal color palette */
      --color-white: #FFFFFF;
      --color-gray-200: #E2E8F0;
      --color-gray-400: #94A3B8;
      --color-gray-600: #475569;
      --color-gray-900: #0F172A;
      --color-blue-500: #2563EB;
      --color-blue-600: #1D4ED8;
      --color-red-500: #EF4444;

      /* Typography scale */
      --font-size-xs: 11px;
      --font-size-sm: 12px;
      --font-size-base: 13px;

      /* Spacing scale */
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;

      /* Border radius */
      --radius-sm: 4px;
      --radius-md: 6px;

      /* Shadows */
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);

      /* Focus ring */
      --focus-ring: 0 0 0 2px var(--color-blue-500);
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: var(--space-2) var(--space-3);
      font-size: var(--font-size-base);
      line-height: 1.4;
      color: var(--color-gray-900);
      background-color: var(--color-white);
    }

    /* Step Container */
    .step {
      margin-bottom: var(--space-2);
      padding-bottom: var(--space-3);
      border-bottom: 1px solid var(--color-gray-200);
    }

    .step-header {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      margin-bottom: var(--space-3);
    }

    .step-number {
      background: var(--color-blue-500);
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--font-size-xs);
      font-weight: 600;
      flex-shrink: 0;
    }

    .step-number.inactive {
      background: var(--color-gray-400);
    }

    .step-title {
      font-weight: 500;
      font-size: var(--font-size-base);
    }

    /* Scan section */
    .scan-row {
      display: flex;
      align-items: baseline;
      gap: var(--space-2);
    }

    .scan-mode {
      font-size: var(--font-size-xs);
      color: var(--color-gray-600);
      margin-bottom: var(--space-2);
    }

    .manual-text {
      font-size: var(--font-size-sm);
      color: var(--color-gray-900);
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: var(--space-2) var(--space-3);
      border: 1px solid var(--color-gray-200);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-sm);
      font-weight: 500;
      background: var(--color-white);
      color: var(--color-gray-900);
      cursor: pointer;
      transition: all 0.15s ease;
      min-height: 28px;
    }

    .btn:hover {
      border-color: var(--color-gray-400);
      transform: translateY(-1px);
    }

    .btn-primary {
      background: var(--color-blue-500);
      color: white;
      border-color: var(--color-blue-500);
      padding: var(--space-3) var(--space-4);
    }

    .btn-primary:hover {
      background: var(--color-blue-600);
      border-color: var(--color-blue-600);
    }

    .btn-small {
      font-size: var(--font-size-xs);
      padding: var(--space-1) var(--space-2);
      min-height: 24px;
    }

    /* Options */
    .options {
      margin: var(--space-2) 0;
    }

    .option-label {
      display: flex;
      align-items: center;
      font-size: var(--font-size-sm);
      margin: var(--space-1) 0;
      cursor: pointer;
    }

    .checkbox {
      width: 14px;
      height: 14px;
      margin-right: var(--space-1);
      accent-color: var(--color-blue-500);
    }

    /* Results */
    .results {
      margin-top: var(--space-3);
    }

    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-2);
    }

    .results-count {
      font-size: var(--font-size-sm);
      color: var(--color-gray-600);
    }

    .results-controls {
      display: none;
      gap: var(--space-1);
    }

    .result-item {
      display: flex;
      align-items: flex-start;
      gap: var(--space-1);
      padding: var(--space-2);
      border: 1px solid var(--color-gray-200);
      border-radius: var(--radius-sm);
      margin-bottom: var(--space-1);
      font-size: var(--font-size-sm);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .result-item:hover {
      border-color: var(--color-gray-400);
      box-shadow: var(--shadow-sm);
    }

    .result-item.selected {
      border-color: var(--color-blue-500);
      background: #f8faff;
    }

    .result-content {
      flex: 1;
      min-width: 0;
    }

    .result-text {
      font-weight: 500;
      margin-bottom: var(--space-1);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .result-changes {
      color: var(--color-gray-600);
      font-size: var(--font-size-xs);
    }

    /* Selection status */
    .selection-status {
      font-size: var(--font-size-sm);
      color: var(--color-gray-600);
      margin-bottom: var(--space-2);
    }

    .selection-status.has-selection {
      color: var(--color-blue-600);
      font-weight: 500;
    }

    /* Tab Navigation */
    .tabs {
      display: flex;
      background: var(--color-gray-200);
      border-radius: var(--radius-sm);
      padding: var(--space-1);
      margin-bottom: var(--space-4);
    }

    .tab {
      flex: 1;
      padding: var(--space-2);
      background: transparent;
      border: none;
      border-radius: var(--radius-sm);
      font-size: var(--font-size-sm);
      cursor: pointer;
      color: var(--color-gray-600);
      transition: all 0.15s ease;
    }

    .tab.active {
      background: var(--color-white);
      color: var(--color-gray-900);
      box-shadow: var(--shadow-sm);
    }

    .tab-panel {
      display: none;
    }

    .tab-panel.active {
      display: block;
    }

    /* Settings */
    .setting {
      margin-bottom: var(--space-3);
    }

    .setting.hidden {
      opacity: 0;
    }

    .setting label {
      display: block;
      font-size: var(--font-size-sm);
      font-weight: 500;
      color: var(--color-gray-900);
      margin-bottom: var(--space-1);
    }

    .input-field,
    .textarea-field {
      width: 100%;
      padding: var(--space-2);
      border: 1px solid var(--color-gray-200);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-sm);
    }

    .input-field:focus,
    .textarea-field:focus {
      border-color: var(--color-blue-500);
      outline: none;
    }

    /* Messages */
    .info {
      color: var(--color-gray-600);
      font-size: var(--font-size-sm);
    }

    .error {
      color: var(--color-red-500);
      font-size: var(--font-size-sm);
    }

    /* Legacy compatibility styles */
    .info-message {
      color: var(--color-gray-600);
      font-size: var(--font-size-sm);
    }

    .error-message {
      color: var(--color-red-500);
      font-size: var(--font-size-sm);
    }

    .warning-message {
      color: var(--color-red-500);
      font-size: var(--font-size-sm);
    }

    /* Accessibility */
    @media (prefers-reduced-motion: reduce) {

      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    *:focus-visible {
      outline: 2px solid var(--color-blue-500);
      outline-offset: 2px;
    }

    .result-item:focus-within {
      box-shadow: var(--focus-ring);
    }
  </style>
</head>

<body>
  <!-- Tab Navigation -->
  <div class="tabs">
    <button class="tab active" id="tab-operations">テキスト操作</button>
    <button class="tab" id="tab-settings">詳細設定</button>
  </div>

  <!-- Operations Panel -->
  <div class="tab-panel active" id="panel-operations">
    <!-- Step 1: テキスト選択 -->
    <div class="step">
      <div class="step-header">
        <div class="step-number">1</div>
        <div class="step-title">テキストを選択</div>
      </div>
      <div class="scan-mode" id="scan-mode-info">スキャンモード: ページ全体</div>
      <div class="scan-row">
        <button id="scan" class="btn btn-primary">スキャン実行</button>
        <span class="manual-text">or 手動選択</span>
      </div>
    </div>

    <!-- Step 2: クリーニング実行 -->
    <div class="step">
      <div class="step-header">
        <div class="step-number inactive" id="step-2-number">2</div>
        <div class="step-title">クリーニング実行</div>
      </div>
      <div class="options">
        <label class="option-label"><input type="checkbox" class="checkbox" id="manual-remove-breaks" checked>
          改行除去</label>
        <label class="option-label"><input type="checkbox" class="checkbox" id="manual-convert-soft-breaks" checked>
          ソフト改行は改行に変換</label>
      </div>
      <div class="selection-status" id="selection-status">テキストを選択してください</div>
      <button id="apply-selected" class="btn btn-primary">選択したテキストをクリーニング</button>
    </div>

    <!-- 検出結果 -->
    <div class="results" id="results-container">
      <div id="results-summary">
        <div class="info"></div>
      </div>
      <div class="results-header" id="results-header" style="display: none;">
        <span class="results-count" id="results-count"></span>
        <div class="results-controls" id="results-controls">
          <button id="select-all" class="btn btn-small">全選択</button>
          <button id="select-none" class="btn btn-small">解除</button>
          <button id="clear-results" class="btn btn-small">クリア</button>
        </div>
      </div>
      <div id="results-list"></div>
    </div>
  </div>

  <!-- Settings Panel -->
  <div class="tab-panel" id="panel-settings">
    <div class="setting">
      <label for="min-chars">スキャン対象の最小文字数:</label>
      <input type="number" class="input-field" id="min-chars" min="1" max="1000" placeholder="20" />
      <small>文字の少ないテキスト要素はスキャンから除外する</small>
    </div>
    <div class="setting">
      <label for="line-break-threshold">改行処理閾値:</label>
      <input type="number" class="input-field" id="line-break-threshold" min="0.1" max="1.0" step="0.1"
        placeholder="0.95" />
      <small>1に近いほど要素幅の右端ギリギリの改行だけを除去する。<br>※半角文字やカーニングがあると計算が狂う場合があります</small>
    </div>
    <div class="setting hidden">
      <label for="font-width-multiplier">フォント幅係数:</label>
      <input type="number" class="input-field" id="font-width-multiplier" min="0.5" max="1.5" step="0.05"
        placeholder="1.0" />
      <small>日本語（全角）の場合、通常は1です</small>
    </div>
    <div class="setting hidden">
      <label for="soft-break-chars">ソフト改行文字:</label>
      <textarea class="textarea-field" id="soft-break-chars" rows="2" placeholder=" (デフォルト: LSEP文字)"></textarea>
    </div>
  </div>

  <script>
    // State management
    let currentResults = [];
    let isProcessing = false;
    let selectedNodeIds = new Set();
    let hasManualSelection = false; // 手動選択の状態を追跡

    // Tab management
    function switchTab(tabName) {
      // Remove active classes
      document.querySelectorAll('.tab').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

      // Add active classes
      document.getElementById(`tab-${tabName}`).classList.add('active');
      document.getElementById(`panel-${tabName}`).classList.add('active');
    }

    // Update step 2 state
    function updateStep2State() {
      const hasSelection = selectedNodeIds.size > 0 || hasManualSelection;
      const step2Number = document.getElementById('step-2-number');
      const selectionStatus = document.getElementById('selection-status');

      if (hasSelection) {
        step2Number.classList.remove('inactive');

        if (selectedNodeIds.size > 0) {
          selectionStatus.textContent = `${selectedNodeIds.size}つのテキストを選択中`;
        } else {
          selectionStatus.textContent = `テキストを選択中`;
        }
        selectionStatus.classList.add('has-selection');
      } else {
        step2Number.classList.add('inactive');
        selectionStatus.textContent = 'テキストを選択してください';
        selectionStatus.classList.remove('has-selection');
      }
    }

    // Show processing status
    function showProcessingStatus(message) {
      const selectionStatus = document.getElementById('selection-status');
      selectionStatus.textContent = message;
      selectionStatus.classList.add('has-selection');
    }

    // Configuration management - relies on values set by code.ts
    function getConfig() {
      const softBreakText = document.getElementById('soft-break-chars').value.trim();

      // 簡素化されたソフト改行文字処理
      let softBreakChars = [];
      if (softBreakText) {
        // 特殊文字コードをチェック
        const specialCodes = [8232, 8233, 8203, 65279]; // LSEP, PSEP, ZWSP, BOM
        for (let i = 0; i < softBreakText.length; i++) {
          const char = softBreakText[i];
          if (specialCodes.includes(char.charCodeAt(0)) && !softBreakChars.includes(char)) {
            softBreakChars.push(char);
          }
        }

        // 通常文字列も追加
        const lines = softBreakText.split(/[\r\n]+/).filter(line => line.trim());
        softBreakChars.push(...lines.filter(line => !softBreakChars.includes(line)));
      }

      // Note: デフォルト値は code.ts の DEFAULT_CONFIG に依存
      // UI側では入力値をそのまま返し、無効値の場合はcode.ts側で処理される
      if (softBreakChars.length === 0) {
        softBreakChars = ['\u2028']; // 最低限のフォールバック
      }

      return {
        minCharacters: parseInt(document.getElementById('min-chars').value),
        lineBreakThreshold: parseFloat(document.getElementById('line-break-threshold').value),
        fontWidthMultiplier: parseFloat(document.getElementById('font-width-multiplier').value),
        softBreakChars: softBreakChars
      };
    }

    // UI State management (simplified)
    // isProcessing state is tracked but no UI changes needed

    function showResults(results, scanInfo) {
      currentResults = results;
      selectedNodeIds.clear();

      const summary = document.getElementById('results-summary');
      const header = document.getElementById('results-header');
      const count = document.getElementById('results-count');
      const controls = document.getElementById('results-controls');
      const list = document.getElementById('results-list');

      const withIssues = results.filter(r => r.issues && r.issues.length > 0);

      if (withIssues.length > 0) {
        summary.style.display = 'none';
        header.style.display = 'flex';
        count.textContent = `${withIssues.length}つのテキストを検出`;
        controls.style.display = 'flex';

        list.innerHTML = '';
        withIssues.forEach(result => {
          const item = document.createElement('div');
          item.className = 'result-item';
          item.dataset.nodeId = result.node.id;

          const textPreview = (result.originalText || '').substring(0, 30) +
            (result.originalText && result.originalText.length > 30 ? '...' : '');

          item.innerHTML = `
                    <input type="checkbox" class="node-checkbox" data-node-id="${result.node.id}">
                    <div class="result-content">
                        <div class="result-text">${textPreview || 'テキスト'}</div>
                        <div class="result-changes">${result.estimatedChanges || '改行の問題'}</div>
                    </div>
                `;

          // Event listeners
          item.addEventListener('click', (e) => {
            if (e.target.type !== 'checkbox') {
              const checkbox = item.querySelector('.node-checkbox');
              checkbox.checked = !checkbox.checked;
              checkbox.dispatchEvent(new Event('change'));
            }
          });

          const checkbox = item.querySelector('.node-checkbox');
          checkbox.addEventListener('change', (e) => {
            const nodeId = e.target.dataset.nodeId;
            if (e.target.checked) {
              selectedNodeIds.add(nodeId);
              item.classList.add('selected');
            } else {
              selectedNodeIds.delete(nodeId);
              item.classList.remove('selected');
            }
            updateStep2State();
            updateSelectionAndFocus();
          });

          list.appendChild(item);
        });
      } else {
        // 結果が0件の場合はUIをリセット
        summary.style.display = 'block';
        header.style.display = 'none';
        count.textContent = '';
        controls.style.display = 'none';
        list.innerHTML = '';

        figma.notify(`問題のあるテキストは見つかりませんでした`);
      }

      updateStep2State();
    }

    function showError(message) {
      figma.notify(`${message}`, { error: true });
    }

    function showWarning(message) {
      figma.notify(`${message}`, { error: true });
    }

    // 選択とフォーカス機能
    function updateSelectionAndFocus() {
      const selectedNodes = currentResults.filter(r => selectedNodeIds.has(r.node.id));

      // Figmaでノードを選択（空の場合も含む）
      parent.postMessage({
        pluginMessage: {
          type: 'select-nodes',
          nodeIds: Array.from(selectedNodeIds)
        }
      }, '*');
    }

    // Figmaの選択変更をUIに反映
    function syncSelectionFromFigma() {
      parent.postMessage({
        pluginMessage: {
          type: 'get-current-selection'
        }
      }, '*');
    }

    // 選択状態は既にcode.tsのselectionchangeイベントで監視されているため削除

    // すべて選択/解除機能
    function selectAllNodes() {
      const checkboxes = document.querySelectorAll('.node-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = true;
        checkbox.dispatchEvent(new Event('change'));
      });
    }

    function selectNoneNodes() {
      selectedNodeIds.clear();
      document.querySelectorAll('.result-item').forEach(item => {
        item.classList.remove('selected');
        const checkbox = item.querySelector('.node-checkbox');
        if (checkbox) checkbox.checked = false;
      });
      updateStep2State();
      updateSelectionAndFocus();
    }

    function clearResults() {
      currentResults = [];
      selectedNodeIds.clear();
      // 手動選択状態はクリアしない（Figmaの選択は保持）

      const summary = document.getElementById('results-summary');
      const header = document.getElementById('results-header');
      const list = document.getElementById('results-list');

      summary.style.display = 'block';
      summary.innerHTML = '<div class="info"></div>';
      header.style.display = 'none';
      list.innerHTML = '';

      // Figmaの現在の選択状態を再取得
      syncSelectionFromFigma();

      parent.postMessage({
        pluginMessage: {
          type: 'clear-results'
        }
      }, '*');
    }

    // Event listeners
    document.getElementById('scan').onclick = () => {
      const config = getConfig();
      isProcessing = true;

      const header = document.getElementById('results-count');
      header.textContent = 'スキャン中...';

      parent.postMessage({
        pluginMessage: {
          type: 'scan',
          config: config
        }
      }, '*');
    };

    // 選択ボタンのイベントリスナー
    document.getElementById('select-all').onclick = selectAllNodes;
    document.getElementById('select-none').onclick = selectNoneNodes;
    document.getElementById('clear-results').onclick = clearResults;

    document.getElementById('apply-selected').onclick = () => {
      const config = getConfig();
      const manualOptions = {
        removeLineBreaks: document.getElementById('manual-remove-breaks').checked,
        convertSoftBreaks: document.getElementById('manual-convert-soft-breaks').checked,
        selectedNodeIds: Array.from(selectedNodeIds) // スキャン結果から選択されたノードIDを送信
      };

      parent.postMessage({
        pluginMessage: {
          type: 'apply-selected',
          config: config,
          options: manualOptions
        }
      }, '*');
    };

    // Tab event listeners
    document.getElementById('tab-operations').onclick = () => switchTab('operations');
    document.getElementById('tab-settings').onclick = () => switchTab('settings');

    // Message handling from plugin
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;

      switch (msg.type) {
        case 'scan-complete':
          isProcessing = false;
          showResults(msg.results, msg.scanInfo);
          break;

        case 'error':
          isProcessing = false;
          // エラー時もUIをリセット
          const errorHeader = document.getElementById('results-count');
          errorHeader.textContent = '';
          document.getElementById('results-header').style.display = 'none';
          showError(msg.message);
          break;

        case 'warning':
          showWarning(msg.message);
          break;

        case 'processing-start':
          showProcessingStatus(`クリーニング中... ${msg.count}つのテキストを処理中`);
          break;

        case 'processing-complete':
          showProcessingStatus(`クリーニング完了！${msg.processedCount}つのテキストを処理しました`);
          // 3秒後に元の状態に戻す
          setTimeout(() => {
            updateStep2State();
          }, 3000);
          break;

        case 'selection-changed':
          updateUISelection(msg.selectedNodeIds, msg.hasManualSelection, msg.manualSelectionCount);
          break;

        case 'config-loaded':
          applyConfigToUI(msg.config);
          break;

        case 'scan-mode-info':
          updateScanModeDisplay(msg.mode, msg.details);
          break;
      }
    };

    // 設定をUIに反映
    function applyConfigToUI(config) {
      // config は既に code.ts の loadConfig() で DEFAULT_CONFIG とマージ済み
      // UIの入力フィールドに値を設定（これが唯一の値の源泉となる）
      document.getElementById('min-chars').value = config.minCharacters;
      document.getElementById('line-break-threshold').value = config.lineBreakThreshold;
      document.getElementById('font-width-multiplier').value = config.fontWidthMultiplier;

      // placeholderもデフォルト値で更新（code.tsから受け取った値を使用）
      document.getElementById('min-chars').placeholder = config.minCharacters;
      document.getElementById('line-break-threshold').placeholder = config.lineBreakThreshold;
      document.getElementById('font-width-multiplier').placeholder = config.fontWidthMultiplier;

      // ソフト改行文字を適切に表示（改行で区切らない）
      document.getElementById('soft-break-chars').value = config.softBreakChars.join('');
      document.getElementById('soft-break-chars').placeholder = ` (デフォルト: ${config.softBreakChars.join('')})`;
    }

    // UIの選択状態を更新
    function updateUISelection(figmaSelectedNodeIds, hasManualSelectionFromFigma = false, manualSelectionCount = 0) {
      selectedNodeIds.clear();
      document.querySelectorAll('.result-item').forEach(item => {
        item.classList.remove('selected');
        const checkbox = item.querySelector('.node-checkbox');
        if (checkbox) {
          checkbox.checked = false;
        }
      });

      // スキャン結果リストにあるノードの選択状態を更新
      figmaSelectedNodeIds.forEach(nodeId => {
        const resultItem = document.querySelector(`[data-node-id="${nodeId}"]`);
        if (resultItem) {
          selectedNodeIds.add(nodeId);
          resultItem.classList.add('selected');
          const checkbox = resultItem.querySelector('.node-checkbox');
          if (checkbox) {
            checkbox.checked = true;
          }
        }
      });

      // 手動選択の状態を更新
      hasManualSelection = hasManualSelectionFromFigma;

      updateStep2State();
    }

    // スキャンモード表示を更新
    function updateScanModeInfo() {
      parent.postMessage({
        pluginMessage: {
          type: 'get-scan-mode'
        }
      }, '*');
    }

    // スキャンモード表示を更新
    function updateScanModeDisplay(mode, details) {
      const scanModeInfo = document.getElementById('scan-mode-info');
      if (scanModeInfo) {
        scanModeInfo.textContent = `スキャンモード: ${mode}${details ? ` (${details})` : ''}`;
      }
    }

    // Initialize
    isProcessing = false;
    updateScanModeInfo();
    updateStep2State();

    // Load saved configuration on startup
    parent.postMessage({
      pluginMessage: {
        type: 'load-config'
      }
    }, '*');

    // 初期選択状態を取得（プラグイン起動時のみ）
    syncSelectionFromFigma();



    // ウィンドウのフォーカス状態を監視
    window.addEventListener('focus', () => {
      updateScanModeInfo(); // 即座に更新
      syncSelectionFromFigma(); // 選択状態も更新
    });


    // ユーザーがUIを操作した時に更新
    document.addEventListener('click', () => {
      updateScanModeInfo();
      syncSelectionFromFigma(); // 選択状態も更新
    });

    // 初期更新
    updateScanModeInfo();
  </script>
</body>

</html>